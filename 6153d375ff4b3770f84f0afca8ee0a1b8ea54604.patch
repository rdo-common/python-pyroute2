diff --git a/pyroute2/devlink.py b/pyroute2/devlink.py
index 45df607..40d87bd 100644
--- a/pyroute2/devlink.py
+++ b/pyroute2/devlink.py
@@ -1,9 +1,12 @@
+import logging
 from pyroute2.netlink import NLM_F_REQUEST
 from pyroute2.netlink import NLM_F_DUMP
 from pyroute2.netlink.devlink import DevlinkSocket
 from pyroute2.netlink.devlink import devlinkcmd
 from pyroute2.netlink.devlink import DEVLINK_NAMES
 
+log = logging.getLogger(__name__)
+
 
 class DL(DevlinkSocket):
 
@@ -17,14 +20,21 @@ class DL(DevlinkSocket):
 
         # get specific async kwarg
         if 'async' in kwarg:
-            async = kwarg['async']
-            del kwarg['async']
+            # FIXME
+            # raise deprecation error after 0.5.3
+            #
+            log.warning('use "async_cache" instead of "async", '
+                        '"async" is a keyword from Python 3.7')
+            kwarg['async_cache'] = kwarg.pop('async')
+
+        if 'async_cache' in kwarg:
+            async_cache = kwarg.pop('async_cache')
         else:
-            async = False
+            async_cache = False
 
-        # align groups with async
+        # align groups with async_cache
         if groups is None:
-            groups = ~0 if async else 0
+            groups = ~0 if async_cache else 0
 
         # continue with init
         super(DL, self).__init__(*argv, **kwarg)
@@ -32,7 +42,7 @@ class DL(DevlinkSocket):
         # do automatic bind
         # FIXME: unfortunately we can not omit it here
         try:
-            self.bind(groups, async)
+            self.bind(groups, async_cache)
         except:
             # thanks to jtluka at redhat.com and the LNST
             # team for the fixed fd leak
diff --git a/pyroute2/ipdb/main.py b/pyroute2/ipdb/main.py
index c209050..7d81a36 100644
--- a/pyroute2/ipdb/main.py
+++ b/pyroute2/ipdb/main.py
@@ -858,7 +858,8 @@ class IPDB(object):
         # setup monitoring socket
         self.mnl = self.nl.clone()
         try:
-            self.mnl.bind(groups=self.nl_bind_groups, async=self._nl_async)
+            self.mnl.bind(groups=self.nl_bind_groups,
+                          async_cache=self._nl_async)
         except:
             self.mnl.close()
             if self._nl_own is None:
diff --git a/pyroute2/iproute.py b/pyroute2/iproute.py
index f1f54f2..795e341 100644
--- a/pyroute2/iproute.py
+++ b/pyroute2/iproute.py
@@ -144,10 +144,10 @@ MUST get all the messages in time. In the case of the
 kernel buffer overflow, you will have to restart the
 socket.
 
-With `IPRoute.bind(async=True)` one can launch async
-message receiver thread with `Queue`-based buffer. The
-buffer is thread-safe and completely transparent from
-the programmer's perspective. Please read also
+With `IPRoute.bind(async_cache=True)` one can launch
+async message receiver thread with `Queue`-based buffer.
+The buffer is thread-safe and completely transparent
+from the programmer's perspective. Please read also
 `NetlinkSocket` documentation to know more about async
 mode.
 
diff --git a/pyroute2/iwutil.py b/pyroute2/iwutil.py
index c7468f7..b3714cd 100644
--- a/pyroute2/iwutil.py
+++ b/pyroute2/iwutil.py
@@ -130,6 +130,7 @@ Submit changes
 Please do not hesitate to submit the changes on github. Without
 your patches this module will not evolve.
 '''
+import logging
 from pyroute2.netlink import NLM_F_ACK
 from pyroute2.netlink import NLM_F_REQUEST
 from pyroute2.netlink import NLM_F_DUMP
@@ -140,6 +141,8 @@ from pyroute2.netlink.nl80211 import IFTYPE_NAMES
 from pyroute2.netlink.nl80211 import CHAN_WIDTH
 from pyroute2.netlink.nl80211 import BSS_STATUS_NAMES
 
+log = logging.getLogger(__name__)
+
 
 class IW(NL80211):
 
@@ -153,21 +156,28 @@ class IW(NL80211):
 
         # get specific async kwarg
         if 'async' in kwarg:
-            async = kwarg['async']
-            del kwarg['async']
+            # FIXME
+            # raise deprecation error after 0.5.3
+            #
+            log.warning('use "async_cache" instead of "async", '
+                        '"async" is a keyword from Python 3.7')
+            kwarg['async_cache'] = kwarg.pop('async')
+
+        if 'async_cache' in kwarg:
+            async_cache = kwarg.pop('async_cache')
         else:
-            async = False
+            async_cache = False
 
-        # align groups with async
+        # align groups with async_cache
         if groups is None:
-            groups = ~0 if async else 0
+            groups = ~0 if async_cache else 0
 
         # continue with init
         super(IW, self).__init__(*argv, **kwarg)
 
         # do automatic bind
         # FIXME: unfortunately we can not omit it here
-        self.bind(groups, async)
+        self.bind(groups, async_cache)
 
     def del_interface(self, dev):
         '''
diff --git a/pyroute2/netlink/devlink/__init__.py b/pyroute2/netlink/devlink/__init__.py
index ad77b0d..da8e3b5 100644
--- a/pyroute2/netlink/devlink/__init__.py
+++ b/pyroute2/netlink/devlink/__init__.py
@@ -126,6 +126,6 @@ class DevlinkSocket(GenericNetlinkSocket):
         GenericNetlinkSocket.__init__(self)
         self.marshal = MarshalDevlink()
 
-    def bind(self, groups=0, async=False):
+    def bind(self, groups=0, **kwarg):
         GenericNetlinkSocket.bind(self, 'devlink', devlinkcmd,
-                                  groups, None, async)
+                                  groups, None, **kwarg)
diff --git a/pyroute2/netlink/event/__init__.py b/pyroute2/netlink/event/__init__.py
index 647e828..a991113 100644
--- a/pyroute2/netlink/event/__init__.py
+++ b/pyroute2/netlink/event/__init__.py
@@ -18,8 +18,8 @@ class EventSocket(GenericNetlinkSocket):
         for group in self.mcast_groups:
             self.add_membership(group)
 
-    def bind(self, groups=0, async=False):
+    def bind(self, groups=0, **kwarg):
         GenericNetlinkSocket.bind(self,
                                   self.genl_family,
                                   self.marshal_class.msg_map[0],
-                                  groups, None, async)
+                                  groups, None, **kwarg)
diff --git a/pyroute2/netlink/generic/__init__.py b/pyroute2/netlink/generic/__init__.py
index b39018e..1f2ca0f 100644
--- a/pyroute2/netlink/generic/__init__.py
+++ b/pyroute2/netlink/generic/__init__.py
@@ -26,14 +26,14 @@ class GenericNetlinkSocket(NetlinkSocket):
 
     mcast_groups = {}
 
-    def bind(self, proto, msg_class, groups=0, pid=None, async=False):
+    def bind(self, proto, msg_class, groups=0, pid=None, **kwarg):
         '''
         Bind the socket and performs generic netlink
         proto lookup. The `proto` parameter is a string,
         like "TASKSTATS", `msg_class` is a class to
         parse messages with.
         '''
-        NetlinkSocket.bind(self, groups, pid, async)
+        NetlinkSocket.bind(self, groups, pid, **kwarg)
         self.marshal.msg_map[GENL_ID_CTRL] = ctrlmsg
         msg = self.discovery(proto)
         self.prid = msg.get_attr('CTRL_ATTR_FAMILY_ID')
diff --git a/pyroute2/netlink/nl80211/__init__.py b/pyroute2/netlink/nl80211/__init__.py
index 606ccb0..31cc027 100644
--- a/pyroute2/netlink/nl80211/__init__.py
+++ b/pyroute2/netlink/nl80211/__init__.py
@@ -638,6 +638,6 @@ class NL80211(GenericNetlinkSocket):
         GenericNetlinkSocket.__init__(self)
         self.marshal = MarshalNl80211()
 
-    def bind(self, groups=0, async=False):
+    def bind(self, groups=0, **kwarg):
         GenericNetlinkSocket.bind(self, 'nl80211', nl80211cmd,
-                                  groups, None, async)
+                                  groups, None, **kwarg)
diff --git a/pyroute2/netlink/nlsocket.py b/pyroute2/netlink/nlsocket.py
index 2a8dff2..e144ee6 100644
--- a/pyroute2/netlink/nlsocket.py
+++ b/pyroute2/netlink/nlsocket.py
@@ -11,8 +11,8 @@ asynchronous I/O
 ----------------
 
 To run async reader thread, one should call
-`NetlinkSocket.bind(async=True)`. In that case a
-background thread will be launched. The thread will
+`NetlinkSocket.bind(async_cache=True)`. In that case
+a background thread will be launched. The thread will
 automatically collect all the messages and store
 into a userspace buffer.
 
@@ -903,7 +903,7 @@ class NetlinkSocket(NetlinkMixin):
         msg.encode()
         return self._sock.sendto(msg.data, addr)
 
-    def bind(self, groups=0, pid=None, async=False):
+    def bind(self, groups=0, pid=None, **kwarg):
         '''
         Bind the socket to given multicast groups, using
         given pid.
@@ -917,6 +917,14 @@ class NetlinkSocket(NetlinkMixin):
             self.fixed = True
             self.pid = pid or os.getpid()
 
+        if 'async' in kwarg:
+            # FIXME
+            # raise deprecation error after 0.5.3
+            #
+            log.warning('use "async_cache" instead of "async", '
+                        '"async" is a keyword from Python 3.7')
+        async_cache = kwarg.get('async_cache') or kwarg.get('async')
+
         self.groups = groups
         # if we have pre-defined port, use it strictly
         if self.fixed:
@@ -936,7 +944,7 @@ class NetlinkSocket(NetlinkMixin):
             else:
                 raise KeyError('no free address available')
         # all is OK till now, so start async recv, if we need
-        if async:
+        if async_cache:
             def recv_plugin(*argv, **kwarg):
                 data_in = self.buffer_queue.get()
                 if isinstance(data_in, Exception):
diff --git a/pyroute2/netlink/rtnl/iprsocket.py b/pyroute2/netlink/rtnl/iprsocket.py
index 7ea43e1..8e68abf 100644
--- a/pyroute2/netlink/rtnl/iprsocket.py
+++ b/pyroute2/netlink/rtnl/iprsocket.py
@@ -46,8 +46,8 @@ class IPRSocketMixin(object):
     def clone(self):
         return type(self)()
 
-    def bind(self, groups=rtnl.RTNL_GROUPS, async=False):
-        super(IPRSocketMixin, self).bind(groups, async=async)
+    def bind(self, groups=rtnl.RTNL_GROUPS, **kwarg):
+        super(IPRSocketMixin, self).bind(groups, **kwarg)
 
     def _gate(self, msg, addr):
         msg.reset()
diff --git a/pyroute2/netlink/rtnl/riprsocket.py b/pyroute2/netlink/rtnl/riprsocket.py
index 037dbaa..192c664 100644
--- a/pyroute2/netlink/rtnl/riprsocket.py
+++ b/pyroute2/netlink/rtnl/riprsocket.py
@@ -10,8 +10,8 @@ class RawIPRSocketMixin(object):
         super(RawIPRSocketMixin, self).__init__(NETLINK_ROUTE, fileno=fileno)
         self.marshal = MarshalRtnl()
 
-    def bind(self, groups=rtnl.RTNL_GROUPS, async=False):
-        super(RawIPRSocketMixin, self).bind(groups, async=async)
+    def bind(self, groups=rtnl.RTNL_GROUPS, **kwarg):
+        super(RawIPRSocketMixin, self).bind(groups, **kwarg)
 
 
 class RawIPRSocket(RawIPRSocketMixin, NetlinkSocket):
diff --git a/pyroute2/remote/__init__.py b/pyroute2/remote/__init__.py
index 7f1ce1f..3ee1f47 100644
--- a/pyroute2/remote/__init__.py
+++ b/pyroute2/remote/__init__.py
@@ -5,6 +5,7 @@ import select
 import signal
 import socket
 import struct
+import logging
 import threading
 import traceback
 from io import BytesIO
@@ -20,6 +21,8 @@ try:
 except ImportError:
     from urllib.parse import urlparse
 
+log = logging.getLogger(__name__)
+
 
 class Transport(object):
     '''
@@ -308,8 +311,14 @@ class Client(object):
 
     def bind(self, *argv, **kwarg):
         if 'async' in kwarg:
-            # do not work with async servers
-            kwarg['async'] = False
+            # FIXME
+            # raise deprecation error after 0.5.3
+            #
+            log.warning('use "async_cache" instead of "async", '
+                        '"async" is a keyword from Python 3.7')
+            del kwarg['async']
+        # do not work with async servers
+        kwarg['async_cache'] = False
         return self.proxy('bind', *argv, **kwarg)
 
     def send(self, *argv, **kwarg):
